#+TITLE:Development Notes
* Introduction :TOC:
- [[#progress][Progress]]
- [[#research][Research]]
- [[#original-program-structure][Original Program Structure]]
  - [[#general-comments][General Comments]]
  - [[#notes][Notes]]
  - [[#definesincludes][Defines(includes)]]
  - [[#initialisation][Initialisation]]
  - [[#main-menu-loop-interfacec][Main Menu Loop (interface.c)]]
  - [[#game-loop][Game Loop]]
  - [[#graphics][Graphics]]
  - [[#graphics-objects-srcdisplayobjects][Graphics Objects (src/display/objects)]]
  - [[#header-file-dependencies][Header file dependencies]]

* Progress
Not much at this stage.

* Research
Programs in /research/ are used to implement, test and evaluate 
various parts of the program.

- /xtank-dlopen/ :: Compile and load a separate program (using *dlopen*), used for
  implementing additional modules. (eg. robot programs, HUD improvements)

- /xtank-pixbuf/ :: Experiment for writing pixbuf images to Gtk4 buffer.
  
- /example-dlopen/ :: A *dlopen* example.

- /example-dlopen/ :: A *gmodule* example. GModule 2.0 is the Portable GLib API for
  dynamically loading modules. 

* Original Program Structure

** General Comments
The following are some idisyncratic features of the xtank code from the original
authors. Not quite easter eggs.

- rorre() :: Function used when getting an error and program can't continue.
  Macro defined in [[src/include/common.h:74]]

- #ifdef REALLY_RUDE :: Only one instance, but adds an additional help message. 

** Notes
- (CLFkr) ConfigRunning, command_options :: Structure used to contain
  configuration. Initially stored in *command_options* in main.c, with settings
  loaded from command line options. Defined in *clfkr.h*

#+begin_src C 
  Boolean AutoExit;	 // Exit immediately after running
  Boolean AutoStart;	 // Skip the main menu and begin
                       // execution automatically?
  Boolean UseSetting;	 // Use a settings file specified
                       // on the command line?
  Boolean PrintScores; // Print scores to standard out after
                       // running a game?
  char *Settings;		 // File from which to load settings.
  Boolean NoDelay;	 // Skip all pauses during gameplay?
  Boolean NoIO;		 // Skip all screen I/O?
#+end_src

- (BSet) bset :: Bullet Set - structure containing data of current bullets in an
  array, and an array/list of pointers to these bullets. *MAX_BULLETS* defined in
  *tanklimits.h.*
  
- (Eset) eset :: Explosion Set - similar structure to handle bullets. *MAX_EXPS*
  defined in *tanklimits.h*.

- (Maze) maze :: Structure which stores vehicle starting location (*Coord*), by
  team. Defined in maze.h.

- Vehicle Arrays :: *actual_vehicles*, **live_vehicles*, **dead_vehicles*, num_veh,
  num_veh_alive, num_veh_dead. The arrays live_vehicles, dead_vehicles are
  pointers into the *actual_vehicles*. Permanently 'dead' vehicles leave holes in
  *actual_vehicles*.

Game Grid - MAX_GRIDS x MAX_VEHICLES
- grid_entries[] :: Array of column name in game grid
- (Byte) grid_val[][] ::
- (char *) grid_ent[][] ::
- (int) grid_id[] ::
  
- players_entries ::
- vehicles_entries ::
- teams_entries ::
Player Details/Combatants
- (Combatant) combatant[MAX_VEHICLES] :: Structure defined in *vehicle.h*, global
  variable defined in *setup.c*.
  - int num_players - 1 (player) or 0 (robot)
  - int player[] - ??? - Setup uses player[0] to contain combatant number. Was
    xtank written to support multiple players per tank?
  
** Defines(includes)
- xtank.h :: Contains a bunch of useful defines. (Includes screen.h, vdesc.h,
  xtanklib.h)

  What are TEST_TURRETS?

- proto.h :: Function prototypes. In the original code this header file
  contained all of the function prototypes for files except for *lowlib*, *highlib*
  (in lowlib).

  Uses a macro *P_* to remove additional parenthesis in the declarations. Why?

  #+begin_src C
#if 1 || defined(__STDC__) || defined(__cplusplus)
#define P_(s) s
#else
#define P_(s) ()
#endif
#+end_src

- maze.h :: Data structures for storing descriptive maze information. Requires
  'teams.h', 'tanklimits.h' to be defined first as it uses *MAX_TEAMS*,
  *MAX_VEHICLES*.

** Initialisation
- init_changed_boxes :: Should be called at the beginning of each frame

- set_terminal() :: Set's the current terminal number.

- get_player_info() :: Prompt a player for their name, and vehicle name (which
  needs to exist).
  
** Main Menu Loop (interface.c)
- main_interface(void) :: Called from main.c to start program. Declared in *proto.h*, defined in *interface.c.*
- set_terminal(0) ::
- init_interface() ::

- fix_combantants(i) (SIC) :: Put player into game grid. Uses *grid_ent*, *grid_val,*
  *players_entries*, *vehicles_entries*, *teams_entries*.

- button_up() ::
- follow_mouse() ::
- display_file() ::
- display_title() ::
- display_settings() ::

- win_exposed() ::
- get_events() :: Get events to process in main event loop.

- menu_hit() ::
- erase_other_menus() :: 
- menu_hit_p() :: Return menu choice by comparing event location (ev.x, ev.y).

- sub_interface_main() ::
- sub_interface_main() ::
- sub_interface_load() ::
- sub_interface_design() ::
- sub_interface_help() ::
- display_settings() ::
- menu_unhighlight() ::
- remove_player() ::
- expose_win() ::
- do_view() ::
- sub_interface_machine() ::
- sub_interface_play() :: See game loop
- sub_interface_settings() ::
- sub_interface_flags() ::
- sub_interface_force() ::
    
- menu_display(Menu_int *menuobj, int menuid) ::  

** Game Loop
- sub_interface_play() :: Choose the type of game to start. Standard, player,
  robots or customize.
Game setups
- standard_combatants() ::  Sets up a combatant for each player and 5 + difficulty/2 robots.
- player_combatants() ::
- robot_combatants() ::
- customized_combatants() ::
- interface_play() ::
- menu_unhighlight() ::

** Graphics
Defines
- ANIM_WIN :: Window id that shows graphics
- HELP_WIN :: Window id that displays help
Globals
- box_type_name[] :: Landmark names  
Functions
- clear_window() ::
- draw_filled_rect() ::
- draw_text() :: Put text on the screen
- draw_objs() ::
- draw_obj() ::
- draw_picture_string() ::
- draw_picture() ::
- draw_text_left() ::

** Graphics Objects (src/display/objects)

The data for graphical objects are stored in a split C data structure, eg. *(Object) medusa_obj* and *(unsigned char) medusa_bitmap[]*, which store meta data and bitmap data respectively.  

Types
- Object :: Screen object, top level data structure
#+begin_src C
  typedef struct {
      char type[MAX_STRING]; // type of object
      int num_pics;          // number of pictures in the screen object
      Picture *pic;			 // array of pictures of the object
      int num_turrets;		 // number of turrets in object
      int num_segs;			 // number of segments to represent object
      Picinfo *picinfo;		 // structure with arrays for turrent locations and collision boundry
  } Object;
#+end_src
  
  Example
#+begin_src C
    #define lightc_views 16
  
    static Object lightc_obj = {
      "lightc",
      lightc_views,
      lightc_pic,
      0,			// num_turrets 
      4,			// num_segs 
      lightc_picinfo
  };

#+end_src
- Picinfo :: The Segment array defines a polygon of the object outline. Used for
  collision detection
#+begin_src C
  typedef struct {
	  Coord turret_coord[MAX_TURRETS];	// relative to center 
	  Segment segment[MAX_SEGMENTS];	// polygon shaped to the picture 
  }
#+end_src
- Picture :: Details of bitmap image. Used to decode raw data in *_pixmap*.
  #+begin_src C
    typedef struct {
        int width;
        int height;
        int offset_x;
        int offset_y;
        int pixmap;
    } Picture;
  #+end_src

- (unsigned char **) pixmap data :: An array of pointers into pixmap arrays, one
  for each picture of the object.

  To decode the *medusa* data stored in *medusa_obj* and *medusa_bitmap[]*, use:
  #+begin_src C
    int pic = 0;  // Picture to extract

    Object *object      = &medusa_obj;
    Picture *picture    = &object->pic[pic];
    unsigned char *data = medusa_bitmap[pic];

    // Object bitmap data is stored as single bit (mono), 8 bit, little-endien, with
    // rows padded to the next byte boundry (byte width).

    int w = picture->width;
    int h = picture->height;
    int byte_width = w/8 + 1;

    fprintf(stderr, "w: %d (%d)  h: %d\n", w, byte_width, h);

    for (int j=0; j<h; j++){
        for(int i=0; i<w; i++){
            int byte = byte_width*j + i/8;
            int bit  = i%8;

            if (data[byte] & 1<<bit) {
                fprintf(stderr, "*");

            } else {
                fprintf(stderr, " ");
            }

        }
        fprintf(stderr, "\n");
    }


  #+end_src

** Header file dependencies
When compiling, the header files are required with the following dependencies.
This reflects the order that header files are requested for the first time. This
list will change if the order the file *#includes* are changed in the source files.

#+begin_src ascii
main.char
- xtank.h
  - screen.h
  - vdesc.h
    - tanktypes.h
      - sysdep.h
    - tanklimits.h
    - vehicleparts.h
      - special-defs.h
      - tread-defs.h
    - object.h
  - xtanklib.h
    - map.h
    - common.h
    - message.h
    - team.h
    - game.h
    - program.h
    - settings.h
      - maze.h
    - lowlib.h
- bullet.h
  - vehicle.h
    - special.h
- clfkr.h
- proto.h
  - mdesign.h
  - setup.h
  - terminal.h
  - graphics.h
    - x11.h
  - thread.h
#+end_src
